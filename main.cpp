#include <windows.h>
#include <stdio.h>

//
// original config of wireless adapter
//
unsigned char wireless_adapter_cfg[] =
{
	0x8c, 0x16, 0x2e, 0x00, 0x06, 0x01, 0x10, 0x00, 0x01, 0x00, 0x80, 0x02, 0x08, 0x00, 0x00, 0x00,
	0x04, 0x00, 0x80, 0xf7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8c, 0x16, 0xa4, 0x30,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x00, 0x00,
	0x01, 0x50, 0xc3, 0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x05, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x10, 0x00, 0x12, 0x00, 0xc0, 0x8c, 0x90, 0x05, 0x00, 0x20, 0x00, 0x00, 0x11, 0x3c, 0x03, 0x00,
	0x40, 0x00, 0x11, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x01, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

//
// our own config
//
unsigned char wireless_adapter_spoof_cfg[] =
{
	0x8c, 0x16, 0x2e, 0x00, 0x06, 0x01, 0x10, 0x00, 0x01, 0x00, 0x80, 0x02, 0x08, 0x00, 0x00, 0x00,
	0x04, 0x00, 0x80, 0xf7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8c, 0x16, 0xa4, 0x30,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x00, 0x00,
	0x01, 0x50, 0xc3, 0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x05, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x10, 0x00, 0x02, 0x00, 0xc0, 0x8c, 0x90, 0x05, 0x00, 0x20, 0x00, 0x00, 0x11, 0x3c, 0x03, 0x00,
	0x40, 0x00, 0x11, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x01, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

#define GET_BITS(data, high, low) ((data >> low) & ((1 << (high - low + 1)) - 1))
#define GET_BIT(data, bit) ((data >> bit) & 1)

void filter_pci_cfg(unsigned char *cfg)
{
	BYTE *cd = (BYTE*)(cfg + 0x09);
	DWORD bar = *(DWORD*)(cfg + 0x10);
	BYTE CapPtr = *(BYTE*)(cfg + 0x34);
	if (CapPtr == 0)
		return;

	printf("[CFG_VEND_ID] [CFG_DEV_ID]			%04X %04X\n", *(WORD*)(cfg + 0x00), *(WORD*)(cfg + 0x02));
	printf("[CFG_SUBSYS_VEND_ID] [CFG_SUBSYS_ID]		%04X %04X\n", *(WORD*)(cfg + 0x2C), *(WORD*)(cfg + 0x2C + 2));
	printf("[CFG_REV_ID]					%ld\n", *(BYTE*)(cfg + 0x08));
	printf("[BAR0]						%lx\n", bar);
	printf("[CLASS_CODE]					%02X%02X%02X\n", cd[2],cd[1],cd[0]);
	printf("\n[CAPABILITIES_PTR] [PM_BASE_PTR]		0x%x 0x%x\n", CapPtr, CapPtr);

	unsigned char *pm_capability = cfg + CapPtr;
	DWORD pm_capabilities = *(DWORD*)&pm_capability[0];
	WORD  pm_capabilites_2 = *(WORD*)(cfg + CapPtr + 0x02);
	WORD cmd = *(WORD*)(cfg + 0x04);

	printf("\n[I/O space enable]				%ld\n",	GET_BIT(cmd, 0));
	printf("[Memory space enable]				%ld\n",	GET_BIT(cmd, 1));
	printf("[Bus master enable]				%ld\n", GET_BIT(cmd, 2));
	printf("[Special cycle enable]				%ld\n", GET_BIT(cmd, 3));
	printf("[Memory write and invalidate enable		%ld\n", GET_BIT(cmd, 4));
	printf("[VGA palette snoop enable]			%ld\n", GET_BIT(cmd, 5));
	printf("[Controls the setting of bit 8 (DATAPAR)]	%ld\n", GET_BIT(cmd, 6));
	printf("[Address/data stepping control]			%ld\n", GET_BIT(cmd, 7));
	printf("[SERR enable bit]				%ld\n", GET_BIT(cmd, 8));
	printf("[Fast back-to-back enable]			%ld\n", GET_BIT(cmd, 9));
	printf("[INTx disable]					%ld\n", GET_BIT(cmd, 10));


	printf("\n[PM_CAP_ON]					%d\n", (pm_capability[2] & 1));
	printf("[PM_CAP_NEXTPTR] [MSI_BASE_PTR]			0x%x 0x%x\n", pm_capability[1], pm_capability[1]);
	printf("[PM_CAP_ID]					%d\n", GET_BITS(pm_capabilities, 7, 0));
	printf("[PM_CAP_PME_CLOCK]				%d\n", GET_BIT(pm_capabilities, 19));
	printf("[PM_CAP_DSI]					%d\n", GET_BIT(pm_capabilities, 21));
	printf("[PM_CAP_AUXCURRENT]				%d\n", GET_BITS(pm_capabilities, 24, 22));
	printf("[PM_CAP_D1SUPPORT PM_CAP_D2SUPPORT]		%d %d\n", GET_BIT(pm_capabilities, 25), GET_BIT(pm_capabilities, 26));
	printf("[PM_CAP_PMESUPPORT]				0x0%x\n", GET_BITS(pm_capabilities, 31, 27));
	printf("[PM_CAP_RSVD_04]				%ld\n", GET_BIT(pm_capabilites_2, 3));
	printf("[PM_CAP_VERSION]				%ld\n", GET_BITS(pm_capabilites_2, 2, 0));

	if (pm_capability[1] == 0)
		return;

	unsigned char *msi_capability = cfg + pm_capability[1];
	DWORD msi_capabilities = *(DWORD*)&msi_capability[0];

	printf("\n[MSI_CAP_ON]					%d\n", (msi_capability[2] & 1));
	printf("[MSI_CAP_NEXTPTR] [PCIE_BASE_PTR]		0x%x 0x%x\n", msi_capability[1], msi_capability[1]);
	printf("[MSI_CAP_ID]					0x0%lx\n", GET_BITS(msi_capabilities, 7, 0));
	printf("[MSI_CAP_MULTIMSGCAP]				%ld\n", GET_BITS(msi_capabilities, 19, 17));
	printf("[MSI_CAP_MULTIMSG_EXTENSION]			%ld\n", GET_BITS(msi_capabilities, 22, 20));
	printf("[MSI_CAP_64_BIT_ADDR_CAPABLE]			%ld\n", GET_BIT(msi_capabilities, 23));
	printf("[MSI_CAP_PER_VECTOR_MASKING_CAPABLE]		%ld\n", GET_BIT(msi_capabilities, 24));

	
	if (msi_capability[1] == 0)
		return;

	unsigned char *pcie_capability = cfg + msi_capability[1];
	DWORD pcie_capabilities = *(DWORD*)&pcie_capability[0];

	
	
	printf("\n[PCIE_CAP_ON]					%d\n", (pcie_capability[2] & 1));
	printf("[PCIE_CAP_NEXTPTR]              		0x%lx\n", pcie_capability[1]);
	printf("[PCIE_CAP_CAPABILITY_ID]              		0x%lx\n", GET_BITS(pcie_capabilities, 7, 0));
	printf("[PCIE_CAP_CAPABILITY_VERSION]			0x%lx\n", GET_BITS(pcie_capabilities, 18, 16));


	
	unsigned char *dev_capability = pcie_capability + 0x04;
	DWORD dev_capabilities = *(DWORD*)&dev_capability[0];


	printf("\n[DEV_CAP_MAX_PAYLOAD_SUPPORTED]			%d\n", GET_BITS(dev_capabilities, 2, 0));
	printf("[DEV_CAP_PHANTOM_FUNCTIONS_SUPPORT]		%ld\n", GET_BITS(dev_capabilities, 4, 3));
	printf("[DEV_CAP_EXT_TAG_SUPPORTED]			%ld\n", GET_BIT(dev_capabilities, 5));
	printf("[DEV_CAP_ENDPOINT_L0S_LATENCY]			%ld\n", GET_BITS(dev_capabilities, 8, 6));
	printf("[DEV_CAP_ENDPOINT_L1_LATENCY]			%ld\n", GET_BITS(dev_capabilities, 11, 9));
	printf("[DEV_CAP_ROLE_BASED_ERROR]			%ld\n", GET_BIT(dev_capabilities, 15));
	printf("[DEV_CAP_ENABLE_SLOT_PWR_LIMIT_VALUE]		%ld\n", GET_BITS(dev_capabilities, 25, 18));
	printf("[DEV_CAP_ENABLE_SLOT_PWR_LIMIT_SCALE]		%ld\n", GET_BITS(dev_capabilities, 27, 26));
	printf("[DEV_CAP_FUNCTION_LEVEL_RESET_CAPABLE]		%ld\n", GET_BIT(dev_capabilities, 28));


	{
		WORD device_ctrl = *(WORD*)(dev_capability + 0x04);
		// printf("device ctrl: %lx\n", device_ctrl);
		printf("\n[Correctable Error Reporting Enable]		%ld\n", GET_BIT(device_ctrl, 0));
		printf("[Non-Fatal Error Reporting Enable]		%ld\n", GET_BIT(device_ctrl, 1));
		printf("[Fatal Error Reporting Enable]			%ld\n", GET_BIT(device_ctrl, 2));
		printf("[Unsupported Request Reporting Enable]		%ld\n", GET_BIT(device_ctrl, 3));
		printf("[Enable Relaxed Ordering]			%ld\n", GET_BIT(device_ctrl, 4));
		printf("[Max_Payload_Size]				%ld\n", GET_BITS(device_ctrl, 7, 5));
		printf("[Extended Tag Field Enable]			%ld\n", GET_BIT(device_ctrl, 8)); // DEV_CONTROL_EXT_TAG_DEFAULT
		printf("[Phantom Functions Enable]			%ld\n", GET_BIT(device_ctrl, 9));
		printf("[Auxiliary Power PM Enable]			%ld\n", GET_BIT(device_ctrl, 10));
		printf("[Enable No Snoop]				%ld\n", GET_BIT(device_ctrl, 11));
		printf("[Max_Read_Request_Size]				%ld\n", GET_BITS(device_ctrl, 14,12));
		printf("[Configuration retry status enable]		%ld\n", GET_BIT(device_ctrl, 15));	
	}
	// SLOT_CAP_SLOT_POWER_LIMIT_VALUE
	
	
	
	
	unsigned char *link_capability = pcie_capability + 0x0C;
	DWORD link_capabilities = *(DWORD*)&link_capability[0];


	printf("\n[LINK_CAP_MAX_LINK_SPEED]			%ld\n", GET_BITS(link_capabilities, 3, 0));
	printf("[LINK_CAP_MAX_LINK_WIDTH]			%ld\n", GET_BITS(link_capabilities, 9, 4));

	printf("[LINK_CAP_ASPM_SUPPORT]				%d\n",  GET_BITS(link_capabilities, 11, 10));
	printf("[LINK_CAP_L0S_EXIT_LATENCY]			%ld\n", GET_BITS(link_capabilities, 14, 12));
	printf("[LINK_CAP_L1_EXIT_LATENCY]			%ld\n", GET_BITS(link_capabilities, 17, 15));
	printf("[LINK_CAP_CLOCK_POWER_MANAGEMENT]		%ld\n", GET_BITS(link_capabilities, 19, 18));
	printf("[LINK_CAP_ASPM_OPTIONALITY]			%ld\n", GET_BIT(link_capabilities, 22));
	printf("[LINK_CAP_RSVD_23]				%ld\n", GET_BITS(link_capabilities, 23, 19));
	{
		DWORD link_ctrl_status = *(DWORD*)(link_capability + 0x04);
		printf("\n[LINK_CONTROL_RCB] 				%ld\n", GET_BIT(link_ctrl_status, 3)); // Read Completion Boundary
		printf("[LINK_STATUS_SLOT_CLOCK_CONFIG] 		%ld\n", GET_BIT(link_ctrl_status, 28)); // Slot Clock Configuration

		DWORD dev_cap2 = *(DWORD*)(link_capability + 0x04 + 0x14);
		printf("\n[CPL_TIMEOUT_RANGES_SUPPORTED]			%ld\n", GET_BITS(dev_cap2, 3, 0));
		printf("[CPL_TIMEOUT_DISABLE_SUPPORTED]			%ld\n", GET_BIT(dev_cap2, 4));

		DWORD dev_ctrl2 = *(DWORD*)(link_capability + 0x04 + 0x14 + 0x04);
		printf("\n[Completion Timeout value]			%ld\n", GET_BITS(dev_ctrl2, 3, 0));
		printf("[Completion Timeout disable]			%ld\n", GET_BIT(dev_ctrl2, 4));

		DWORD link_cap2 = *(DWORD*)(link_capability + 0x04 + 0x14 + 0x08);
		printf("[Link speeds supported]				%ld\n", GET_BITS(link_cap2, 3, 1));

		DWORD link_ctrl2 = *(DWORD*)(link_capability + 0x04 + 0x14 + 0xC);
		

		printf("\n[LINK_CTRL2_TARGET_LINK_SPEED]			%d\n",  GET_BITS(link_ctrl2, 3, 0));
		printf("[Enter Compliance]				%ld\n", GET_BIT(link_ctrl2, 4));
		printf("[LINK_CTRL2_HW_AUTONOMOUS_SPEED_DISABLE]	%ld\n", GET_BIT(link_ctrl2, 5));
		printf("[LINK_CTRL2_DEEMPHASIS]				%ld\n", GET_BIT(link_ctrl2, 6));
		printf("[Transmit Margin]				%ld\n", GET_BITS(link_ctrl2, 9, 7));
		printf("[Enter Modified Compliance]			%ld\n", GET_BIT(link_ctrl2, 10));
		printf("[Compliance SOS]				%d\n",  GET_BIT(link_ctrl2, 11));
		printf("[Compliance Preset/De-emphasis]			%ld\n", GET_BITS(link_ctrl2, 15, 12));
		printf("[Current De-emphasis Level]			%ld\n", GET_BIT(link_ctrl2, 16));
		printf("[Equalization Complete]				%ld\n", GET_BIT(link_ctrl2, 17));
		printf("[Equalization Phase 1 Successful]		%ld\n", GET_BIT(link_ctrl2, 18));
		printf("[Equalization Phase 2 Successful]		%ld\n", GET_BIT(link_ctrl2, 19));
		printf("[Equalization Phase 3 Successful]		%ld\n", GET_BIT(link_ctrl2, 20));
		printf("[Link Equalization Request]			%ld\n", GET_BIT(link_ctrl2, 21));
	}


	
	unsigned char *dsn_capability = cfg + 0x100;
	DWORD dsn_capabilities = *(DWORD*)&dsn_capability[0];
	printf("\n[DSN_CAP_NEXTPTR]				0x%lx\n", *(WORD*)&dsn_capability[2] >> 4);
	printf("[DSN_CAP_ON]					%ld\n", dsn_capability[0] & 1);
	printf("[DSN_CAP_ID]					0x0%lx\n", dsn_capability[0]);
}

void FontColor(int color=0x07)
{
    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color);
}

void compare_cfg(unsigned char *cfg, unsigned char *orig_cfg)
{
	printf("\n     00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\n\n");

	int line_counter=0;
	for (int i = 0; i < 256; i++)
	{
		if (line_counter == 0)
		{
			printf("%02X   ", i);
		}

		line_counter++;


		if (cfg[i] == orig_cfg[i])
			printf("%02X ", cfg[i]);
		else
		{
			FontColor(2);
			printf("%02X ", orig_cfg[i]);
			FontColor();
		}

		if (line_counter == 16)
		{
			printf("\n");
			line_counter=0;
		}
		
	}

	printf("\n");

	line_counter=0;
	for (int i = 0; i < 256; i++)
	{
		if (line_counter == 0)
		{
			printf("%02X   ", i);
		}

		line_counter++;


		if (cfg[i] == orig_cfg[i])
			printf("%02X ", cfg[i]);
		else
		{
			FontColor(4);
			printf("%02X ", cfg[i]);
			FontColor();
		}

		if (line_counter == 16)
		{
			printf("\n");
			line_counter=0;
		}
		
	}
}

int main(void)
{
	compare_cfg(wireless_adapter_spoof_cfg, wireless_adapter_cfg);

	printf("Press any key to continue . . .");
	getchar();
	printf("\n\n");
	

	filter_pci_cfg(wireless_adapter_cfg);

	return getchar();
}
